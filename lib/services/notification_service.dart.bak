import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'dart:convert';

enum NotificationType {
  eventReminder,
  newMessage,
  pointsAwarded,
  eventCreated,
  eventCancelled,
}

class NotificationSettings {
  final bool enabled;
  final bool eventReminders;
  final bool chatMessages;
  final bool pointsUpdates;
  final int reminderHours;
  final int reminderMinutes;

  NotificationSettings({
    this.enabled = true,
    this.eventReminders = true,
    this.chatMessages = true,
    this.pointsUpdates = true,
    this.reminderHours = 24,
    this.reminderMinutes = 30,
  });

  factory NotificationSettings.fromJson(Map<String, dynamic> json) {
    return NotificationSettings(
      enabled: json['enabled'] ?? true,
      eventReminders: json['eventReminders'] ?? true,
      chatMessages: json['chatMessages'] ?? true,
      pointsUpdates: json['pointsUpdates'] ?? true,
      reminderHours: json['reminderHours'] ?? 24,
      reminderMinutes: json['reminderMinutes'] ?? 30,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'enabled': enabled,
      'eventReminders': eventReminders,
      'chatMessages': chatMessages,
      'pointsUpdates': pointsUpdates,
      'reminderHours': reminderHours,
      'reminderMinutes': reminderMinutes,
    };
  }

  NotificationSettings copyWith({
    bool? enabled,
    bool? eventReminders,
    bool? chatMessages,
    bool? pointsUpdates,
    int? reminderHours,
    int? reminderMinutes,
  }) {
    return NotificationSettings(
      enabled: enabled ?? this.enabled,
      eventReminders: eventReminders ?? this.eventReminders,
      chatMessages: chatMessages ?? this.chatMessages,
      pointsUpdates: pointsUpdates ?? this.pointsUpdates,
      reminderHours: reminderHours ?? this.reminderHours,
      reminderMinutes: reminderMinutes ?? this.reminderMinutes,
    );
  }
}

class NotificationService {
  static NotificationService? _instance;
  NotificationService._();

  factory NotificationService() {
    _instance ??= NotificationService._();
    return _instance!;
  }

  static const String _settingsKey = 'notification_settings';
  NotificationSettings _settings = NotificationSettings();
  FirebaseMessaging? _messaging;
  String? _fcmToken;

  NotificationSettings get settings => _settings;
  String? get fcmToken => _fcmToken;

  Future<void> initialize() async {
    await _loadSettings();
    
    // Initialize push notifications if enabled
    if (_settings.enabled) {
      await _initializePushNotifications();
    }
  }

  Future<void> _loadSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final settingsJson = prefs.getString(_settingsKey);
      
      if (settingsJson != null) {
        final Map<String, dynamic> settingsMap = json.decode(settingsJson);
        _settings = NotificationSettings.fromJson(settingsMap);
      }
    } catch (e) {
      debugPrint('Error loading notification settings: $e');
    }
  }

  Future<void> updateSettings(NotificationSettings newSettings) async {
    _settings = newSettings;
    await _saveSettings();
    
    // Update push notification configuration
    if (_settings.enabled) {
      await _initializePushNotifications();
    } else {
      await _disablePushNotifications();
    }
  }

  Future<void> _saveSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_settingsKey, json.encode(_settings.toJson()));
    } catch (e) {
      debugPrint('Error saving notification settings: $e');
    }
  }

  Future<void> _initializePushNotifications() async {
    try {
      _messaging = FirebaseMessaging.instance;
      
      // Request permission for notifications
      final notificationSettings = await _messaging!.requestPermission(
        alert: true,
        badge: true,
        sound: true,
        provisional: false,
      );

      if (notificationSettings.authorizationStatus == AuthorizationStatus.authorized) {
        debugPrint('üîî Push notifications permission granted');
        
        // Get FCM token
        _fcmToken = await _messaging!.getToken();
        debugPrint('üì± FCM Token: $_fcmToken');
        
        // Configure foreground message handling
        FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
        
        // Configure background message handling
        FirebaseMessaging.onMessageOpenedApp.listen(_handleBackgroundMessage);
        
        debugPrint('üîî Push notifications initialized successfully');
      } else {
        debugPrint('üîï Push notifications permission denied');
      }
    } catch (e) {
      debugPrint('‚ùå Error initializing push notifications: $e');
    }
  }

  Future<void> _disablePushNotifications() async {
    try {
      await _messaging?.deleteToken();
      _fcmToken = null;
      debugPrint('üîï Push notifications disabled');
    } catch (e) {
      debugPrint('‚ùå Error disabling push notifications: $e');
    }
  }

  void _handleForegroundMessage(RemoteMessage message) {
    debugPrint('üì± Foreground message received: ${message.notification?.title}');
    
    // Show in-app notification or update UI
    if (message.notification != null) {
      _showLocalNotification(
        title: message.notification!.title ?? 'Stammtisch App',
        body: message.notification!.body ?? '',
        data: message.data,
      );
    }
  }

  void _handleBackgroundMessage(RemoteMessage message) {
    debugPrint('üì± Background message opened: ${message.notification?.title}');
    
    // Handle navigation based on message data
    if (message.data['type'] == 'chat') {
      // Navigate to chat screen
    } else if (message.data['type'] == 'event') {
      // Navigate to event screen
    }
  }

  void _showLocalNotification({
    required String title,
    required String body,
    Map<String, dynamic>? data,
  }) {
    // This would show a local notification overlay
    // For now, just log the notification
    debugPrint('üîî Local notification: $title - $body');
  }

  Future<void> scheduleEventReminder({
    required String eventId,
    required DateTime eventDate,
    required String eventTitle,
  }) async {
    if (!_settings.enabled || !_settings.eventReminders) return;

    final reminderDate = eventDate.subtract(Duration(
      hours: _settings.reminderHours,
      minutes: _settings.reminderMinutes,
    ));

    // TODO: Schedule local notification
    debugPrint('üìÖ Event reminder scheduled for $reminderDate: $eventTitle');
  }

  Future<void> showPointsNotification({
    required String userId,
    required int points,
    required String reason,
  }) async {
    if (!_settings.enabled || !_settings.pointsUpdates) return;

    // TODO: Show local notification
    debugPrint('‚≠ê Points notification: +$points for $reason');
  }

  Future<void> showChatNotification({
    required String groupName,
    required String senderName,
    required String message,
  }) async {
    if (!_settings.enabled || !_settings.chatMessages) return;

    // TODO: Show local notification
    debugPrint('üí¨ Chat notification from $senderName in $groupName: $message');
  }

  Future<void> cancelEventReminder(String eventId) async {
    // TODO: Cancel scheduled notification
    debugPrint('‚ùå Event reminder cancelled for $eventId');
  }

  Future<void> cancelAllNotifications() async {
    // TODO: Cancel all scheduled notifications
    debugPrint('üö´ All notifications cancelled');
  }

  Future<bool> requestPermissions() async {
    try {
      if (_messaging == null) {
        _messaging = FirebaseMessaging.instance;
      }
      
      final settings = await _messaging!.requestPermission(
        alert: true,
        badge: true,
        sound: true,
        provisional: false,
      );
      
      return settings.authorizationStatus == AuthorizationStatus.authorized;
    } catch (e) {
      debugPrint('‚ùå Error requesting notification permissions: $e');
      return false;
    }
  }

  Future<bool> hasPermissions() async {
    try {
      if (_messaging == null) {
        _messaging = FirebaseMessaging.instance;
      }
      
      final settings = await _messaging!.getNotificationSettings();
      return settings.authorizationStatus == AuthorizationStatus.authorized;
    } catch (e) {
      debugPrint('‚ùå Error checking notification permissions: $e');
      return false;
    }
  }

  // Methoden f√ºr ReminderSettingsScreen-Kompatibilit√§t
  Future<Map<String, bool>> getNotificationSettings() async {
    return {
      '1_day': _settings.reminderHours >= 24,
      '1_hour': _settings.reminderHours >= 1 || _settings.reminderMinutes >= 60,
      '30_min': _settings.reminderMinutes >= 30,
    };
  }

  Future<void> updateNotificationSettings({
    required bool oneDayBefore,
    required bool oneHourBefore, 
    required bool thirtyMinBefore,
  }) async {
    // Bestimme die Reminder-Einstellungen basierend auf den Schaltern
    int reminderHours = 0;
    int reminderMinutes = 0;
    
    if (oneDayBefore) {
      reminderHours = 24;
    } else if (oneHourBefore) {
      reminderHours = 1;
    } else if (thirtyMinBefore) {
      reminderMinutes = 30;
    }

    final newSettings = _settings.copyWith(
      reminderHours: reminderHours,
      reminderMinutes: reminderMinutes,
    );
    
    await updateSettings(newSettings);
  }

  Future<void> sendTestNotification() async {
    // TODO: Echte Test-Benachrichtigung senden
    debugPrint('üîî Test notification sent (placeholder)');
  }
}